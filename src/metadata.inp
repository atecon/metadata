function string trim_extra_lines(const string buffer)

    if nelem(buffer) == 0
        return ""
    endif
    return strsplit(buffer, "\n")[1]
end function


function scalar version_is_ok (void)
    /* */

    if $version >= 20205
        return TRUE
    else
        printError("At minimum Gretl version 2020e required.")
        return FALSE
    endif
end function

function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function


function scalar read_and_add_xml_buffer (bundle *self)
    /* Read gdt file which has a xml structure. */

    catch self.xml_buffer = readfile(self.filename)
    if $error
        printError(sprintf("Failed to read file '%s'. Abort.\n", self.filename))
        return TRUE
    else
        return FALSE
    endif
end function


# TODO: test
function bundle get_paths_to_parse (void)
    /* Config paths which should be parsed. */

    bundle Paths = _(\
                        description = "//description", \
                        version = "//gretldata[1]/@version", \
                        name = "//gretldata[1]/@name", \
                        t1 = "//gretldata[1]/@startobs", \
                        t2 = "//gretldata[1]/@endobs", \
                        type = "//gretldata[1]/@type", \
                        pd = "//gretldata[1]/@frequency", \
                        nvar = "/gretldata[1]/variables/@count", \
                        n_string_vars = "/gretldata[1]/string-tables/@count" \
                    )

    return Paths
end function

# TODO: test
function strings get_variable_keys_to_parse (void)
    /* Keys of metadata for each variable/ series to parse. */

    strings variable_keys = defarray("name", "label", "discrete")

    return variable_keys
end function

function string get_path_content (const string path "xpath identifier",
                                  const string xml_buffer,
                                  scalar *n_got "Number of occurences of path")
    /* Extract content of some path in xml. */

    string path_content

    path_content = xmlget(xml_buffer, path, &n_got)
    if $error
        printWarning(sprintf("Failed to find the path '%s'. Ignore.", path))
    endif

    return path_content
end function


function bundle extract_prepare_path_contents (const bundle self)
    /* Loop over all specified paths and extract its contens from xml buffer. Store output in a key-value store. */

    bundle PathContents
    strings keys = getkeys(self.get_paths_to_parse)

    loop foreach i keys
        scalar n_got = 0
        string keyname = sprintf("%s", "$i")

        string PathContents["@keyname"] = \
                get_path_content(\
                                self.get_paths_to_parse["$i"],\
                                self.xml_buffer, &n_got)

        if n_got
            PathContents["@keyname"] = trim_extra_lines(PathContents["@keyname"])
        endif
    endloop

    return PathContents
end function


function strings get_value_names_to_cast_to_int (void)
    /* Array of keys for which values should be cast to integers. */
    return defarray("pd", "nvar", "n_string_vars")
end function


function void cast_value_to_integer (bundle *B)
    /* Cast string values for keys to integers. */

    strings keys = get_value_names_to_cast_to_int()

    loop foreach i keys
        if inbundle(B, "$i")
            scalar B["$i"] = atof(B["$i"])
        endif
    endloop
end function


function void cast_discrete_value (bundle *VariableContents)
    /* Set the key "discrete" to 0 if not existing and to 1 if "true". Per default this key is an empty string when not existing but "true" if existing. */

    strings variable_id = getkeys(VariableContents)

    loop foreach i variable_id
        if inbundle(VariableContents["$i"], "discrete")
            VariableContents["$i"].discrete = TRUE
        else
            VariableContents["$i"].discrete = FALSE
        endif
    endloop
end function



function bundle extract_variable_contents (const bundle PathContents,
                                           const string xml_buffer)
    /* Compile dictionary for each variable in data set. "key" refers to i-th variable_%d and "value" holds another dictionary referring to the metadata available for the i-th variable such as "name", "label" ect. */

    bundle VariableContents
    strings variable_keys = get_variable_keys_to_parse()

    loop i=1..PathContents.nvar

        string path = sprintf("/gretldata[1]/variables/variable[%d]/", i)

        string variable_id = sprintf("variable_%d", $i)
        bundle VariableContents["@variable_id"] = null

        loop foreach j variable_keys
            scalar n_got = 0
            string key = sprintf("%s%s%s", path, "@", "$j")

            string content = get_path_content(key, xml_buffer, &n_got)
            VariableContents["@variable_id"]["$j"] = trim_extra_lines(content)
        endloop
    endloop

    return VariableContents
end function


function bundle extract_series_metadata (const bundle PathContents,
                                         const string xml_buffer)
    /* Extract and compile for each series information such as:

        string_valued: Flag whether series is string-valued (TRUE) or not (FALSE)
        strvals: Number of distinct string-values if series is string-valued.
        name: Name of series
        discrete: Flag whether series is discrete
        label: Label of series
     */

    bundle B

    if PathContents.n_string_vars

        loop i=1..PathContents.n_string_vars

            scalar n_got = 0
            path = sprintf("/gretldata[1]/string-tables/valstrings[%d]/", i)
            string key = sprintf("%s%s", path, "@owner")

            string owner = get_path_content(key, xml_buffer, &n_got)
            owner = trim_extra_lines(owner)

            owner
            stop

            nv = find_owner(owner, varmetadata)
            varmetadata[nv].string_valued = 1

            raw = trim_extra_lines(xmlget(s, path))
            sep = sprintf("\" \"")
            dq = sprintf("\"")
            raw = strsub(raw, sep, "|")
            raw = strsub(raw, dq, "")

            varmetadata[nv]["strvals"] = strsplit(raw, "|")
        endloop
    endif

    return B
end function



function bundle get_gdtinfo (const string filename)
    /* */

    bundle self = null
    string self.filename = filename

    if !version_is_ok()
        return null
    endif

    err = read_and_add_xml_buffer(&self)
    if err
        return null
    endif

    bundle self.get_paths_to_parse = get_paths_to_parse()

    bundle PathContents = extract_prepare_path_contents(self)
    cast_value_to_integer(&PathContents)

    bundle VariableContents = extract_variable_contents(PathContents, \
                                                        self.xml_buffer)
    cast_discrete_value(&VariableContents)


    bundle StringValueContents = extract_series_metadata(\
                                    PathContents, \
                                    self.xml_buffer)


    return ret
end function

function void gdtinfo_print(bundle b, int verbose[0])
    printf "%s, %s. Contains %d series\n", b.name, b.type, b.nvar
    printf "first obs: %s, last obs: %s\n", b.t1, b.t2
    if verbose
        loop i = 1 .. b.nvar
            md = b.varmetadata[i]
            printf "%3d: %-32s", i, md.name
            printf "%s", md.discrete ? " D" : "  "
            printf "%s", md.string_valued ? "S" : " "
            if inbundle(md, "label")
                printf " %s", md.label
            endif
            printf "\n"
        endloop
    endif
    printf "\n\n"
end function

